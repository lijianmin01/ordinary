## 2021.5.12 8:29

### 什么是排序？
* 排序（Sort）,就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。

### 排序算法的评价指标
* 时间复杂度
* 空间复杂度
* 算法的稳定性
* * 若待排序中有两个元素R1和R2的相对位置字在排序v之后没有发生变化，则称这个排序v算法是稳定的，否则称这个排序算法是不稳定的。

## 分类
* 内部排序（数据都在内存中）
* 外部排序（数据太多，无法全部放入内存中）
#### 算法可视化网站
* cs.usfca.edu

### 插入排序
* 算法思想：每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列中，直到全部记录插入完成。

"""c

    // 直接插入排序
    void InsertSort(int A[],int n){
        int i,j,temp;
        for(i=1;i<n;i++){
            if(A[i]<A[i-1]){
                temp = A[i];
                for(j=i-1;j>=0&&A[j]>temp;j--){
                    A[j+1]=A[j];
                }
                A[j+1]=temp;
            }
        }
    }

    /* 有哨兵的直接插入排序（0的位置空出来）
    n 数组长度
    */
    void InsertSort2(int A[],int n){
        int i,j;
        for ( i = 2; i < n; i++)
        {
            if(A[i]<A[i-1]){
                A[0]=A[i];
                for(j=i-1;j>=1 && A[j]>A[0];j--){
                    A[j+1]=A[j];
                }
                A[j+1]=A[0];
            }
        } 
    }
"""
## 复杂度
* 空间复杂度：O(1)
* 时间复杂度：主要来自对比关键字，移动元素，若有n个元素，咋需要N-1 趟处理。
* 最好时间复杂度（全部有序）：O(n)
* 最坏时间复杂度（全部逆序）：O(n^2)
* 平均时间复杂度：O(n)
* 算法稳定性：稳定

## 优化——折半插入排序
* 先用折半查找应该找到的位置，在移动元素
"""c

    /* 优化——折半插入排序
    有哨兵的
    */
    void InsertSort3(int A[],int n){
        int i,j,low,mid,high;
        for(i=2;i<n;i++){
            if(A[i]<A[i-1]){
                A[0]=A[i];
                low = 1;
                high = i-1;
                while(high>=low){
                    mid = (low+high)/2;
                    if(A[mid]>A[0]){
                        high=mid-1;
                    }else{
                        low = mid+1;
                    }
                }
                for(j=i-1;j>=high+1;j--){
                    A[j+1]=A[j];
                }
                A[high+1]=A[0];
            }
        }
    }
"""

## 冒泡排序
#### 交换排序
* 冒泡排序v
* 快速排序
* * 基于“交换”的排序v：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。
  
* 从后往前（或者从前往后）两两比较相邻元素的值，若为逆序v,则交换他们，直到序列比较完。称这样的过程为“一趟”冒泡排序v.

### 代码

“”“c

    /*交换两个元素的位置*/
    void swap(int &a,int &b){
        int temp = a;
        a = b;
        b = temp;
    }

    //冒泡排序v
    void BubbleSort(int A[],int n){
        int i,j;
        for ( i = 0; i < n-1; i++)
        {
            bool flag = false;
            for ( j = n-1; j > i ; j--)
            {
                if (A[j-1]>A[j]){
                    swap(A[j-1],A[j]);
                    flag=true;
                }
            }
            if(flag==false){
                return;
            }   
        }
    }
”“”